import pandas as pd
from datetime import datetime

def create_time_based_features(df):
    """Extracts useful time-based features from the date column."""
    # Convert the date column to datetime format if it's not already
    df['date'] = pd.to_datetime(df['date'])

    # Extract components from the date
    df['hour'] = df['date'].dt.hour               # Hour of the day
    df['day_of_week'] = df['date'].dt.dayofweek    # Day of the week (0 = Monday, 6 = Sunday)
    df['month'] = df['date'].dt.month             # Month (1 = January, 12 = December)
    df['weekend'] = df['date'].dt.weekday >= 5    # Is the day a weekend?

    # Drop the original 'date' column (since we won't be using it directly in the model)
    df = df.drop(columns=['date'])
    
    return df

def create_lag_features(df, lag_hours=1):
    """Creates lag features for the AQI and other pollutants to include past values as features."""
    for feature in ['aqi', 'pm2_5', 'pm10', 'co', 'no', 'no2', 'o3', 'so2', 'nh3']:
        df[f'{feature}_lag_{lag_hours}h'] = df[feature].shift(lag_hours)
    
    # Remove rows with NaN values generated by shifting (lagging)
    df = df.dropna()
    
    return df

if __name__ == "__main__":
    # Load the processed data
    df = pd.read_csv('data/processed/combined_aqi_data_pune.csv')

    # Step 1: Create time-based features (hour, day_of_week, month, weekend)
    df = create_time_based_features(df)
    
    # Step 2: Create lag features (e.g., AQI, PM2.5, etc., from the previous hour)
    df = create_lag_features(df, lag_hours=1)  # Adjust lag_hours as needed

    # Step 3: Save the feature-engineered data to a new CSV
    df.to_csv('data/processed/engineered_aqi_data_pune.csv', index=False)
    print("Feature engineering completed. Data saved to 'engineered_aqi_data_pune.csv'.")
